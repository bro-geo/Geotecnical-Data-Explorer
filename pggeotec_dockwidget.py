# -*- coding: utf-8 -*-
"""
/***************************************************************************
 gdeDockWidget
                                 A QGIS plugin
 Plugin for postgres pggeotec extension
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-03-23
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Bruno Oliveira
        email                : brunorodriguesoli@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal

# custom imports
from .pggeotec_database import databaseFunctions as dbf
from .pggeotec_stat import statFunctions as sf
from .pggeotec_utilities import utilsFunctions as utils

# Third parties libraries

### Plots
from matplotlib.figure import Figure
from matplotlib import rcParams
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib import pyplot

### statistics
from numpy import log, mean, std, amin, median, amax, var, percentile, sort, arange, zeros, meshgrid, stack

### Database
from pandas import read_sql_query



###########################################################################
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'pggeotec_dockwidget_base.ui'))


class gdeDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(gdeDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        ############################################################################
        #### Figures objects
        ############################################################################
        self.figurePlot()
        self.figure3dPlot()
        self.colorTypes()

        rcParams["font.serif"] = "Verdana, Arial, Liberation Serif"
        rcParams["font.sans-serif"] = "Tahoma, Arial, Liberation Sans"
        rcParams["font.cursive"] = "Courier New, Arial, Liberation Sans"
        rcParams["font.fantasy"] = "Comic Sans MS, Arial, Liberation Sans"
        rcParams["font.monospace"] = "Courier New, Liberation Mono"


        ############################################################################
        #### stateChanged
        ############################################################################
        self.checkShowGrid.stateChanged.connect(self.axesAddGrid)
        self.checkVerticalSection.stateChanged.connect(self.checkVertical)
        self.checkHorizontalSection.stateChanged.connect(self.checkHorizontal)


        ############################################################################
        #### Clicked
        ############################################################################
        # Database
        self.pushButtonCreateDatabase.clicked.connect(self.createExtensionExecute)
        self.pushButtonRefreshMatviews.clicked.connect(self.refreshMatviewsExecute)
        self.pushButtonDropExtension.clicked.connect(self.dropExtensionExecute)
        self.pushButtonST_Instrumentacao3D.clicked.connect(self.executeST_Instrumentacao3D)
        self.pushButtonST_Investigacoes3D.clicked.connect(self.executeST_Investigacao3D)
        self.pushButtonST_AmostraCaixa3D.clicked.connect(self.executeST_AmostraCaixa3D)
        self.pushButtonST_EnsaiosCampo3D.clicked.connect(self.executeST_EnsaiosCampo3D)
        self.pushButtonST_AmostraCilindro3D.clicked.connect(self.executeST_AmostraCilindro3D)
        self.pushButtonST_Sondagens3D.clicked.connect(self.executeST_Sondagens3D)
        self.pushButtonST_EnsaiosCilindro3D.clicked.connect(self.executeST_EnsaiosCilindro3D)
        self.pushButtonST_EnsaiosCaixa3D.clicked.connect(self.executeST_EnsaiosCaixa3D)
        self.pushButtonST_UnidadeSolo3D.clicked.connect(self.executeST_UnidadeSolo3D)
        self.pushButtonST_UnidadeRocha3D.clicked.connect(self.executeST_UnidadeRocha3D)
        self.pushButtonST_UpdateGeometrySRID.clicked.connect(self.executeST_UpdateGeometrySRID)
        self.pushButtonvalidateSelectedGeociu.clicked.connect(self.executeValidateSelectedGeociu)
        self.pushButtonTurnOffKeysIndex.clicked.connect(self.executeTurnOffKeysIndex)
        self.pushButtonTurnOnKeysIndex.clicked.connect(self.executeTurnOnKeysIndex)
        self.pushButtonDropPermissions.clicked.connect(self.executeDropPermissions)
        self.pushButtonAddPermissions.clicked.connect(self.executeAddPermissions)
        self.pushButtonDropSpecificConstraints.clicked.connect(self.executeDropSpecificConstraints)
        self.pushButtonAddSpecificConstraints.clicked.connect(self.executeAddSpecificConstraints)
        self.pushButtonDropNotNullConstraints.clicked.connect(self.executeDropNotNullConstraints)
        self.pushButtonAddNotNullConstraints.clicked.connect(self.executeAddNotNullConstraints)
        self.pushButtonDropIndex.clicked.connect(self.executeDropIndex)
        self.pushButtonCreateIndex.clicked.connect(self.executeCreateIndex)
        self.pushButtonDropGeometryIndex.clicked.connect(self.executeDropGeometryIndex)
        self.pushButtonCreateGeometryIndex.clicked.connect(self.executeCreateGeometryIndex)
        self.pushButtonDropForeignKeys.clicked.connect(self.executeDropForeignKeys)
        self.pushButtonAddForeignKeys.clicked.connect(self.executeAddForeignKeys)
        self.pushButtonDropPrimaryKeys.clicked.connect(self.executeDropPrimaryKeys)
        self.pushButtonAddPrimaryKeys.clicked.connect(self.executeAddPrimaryKeys)
        self.pushButtonDropTriggers.clicked.connect(self.executeDropTriggers)
        self.pushButtonAddTriggers.clicked.connect(self.executeAddTriggers)
        self.pushButtonConfigureDomain.clicked.connect(self.configureDomain)
        self.pushButtonCalculateExtent.clicked.connect(self.calculateGrid)

        # Graph
        self.pushButtonHistogram.clicked.connect(self.histogram)
        self.pushButtonScatter.clicked.connect(self.scatterPlot)
        self.pushButtonBoxplot.clicked.connect(self.boxPlot)
        self.pushButtonQQplot.clicked.connect(self.qqPlot)
        self.pushButtonPlot3d.clicked.connect(self.plot3d)
        self.pushButtonStatistics.clicked.connect(self.statistics)
        self.pushButtonEcdf.clicked.connect(self.ecdfPlot)
        self.pushButtonMultiple.clicked.connect(self.multiplePlot)
        self.pushButtondepthWetSPTGenerateGraph.clicked.connect(self.depthWetSPTGenerateGraph)
        self.pushButtondepthDrySPTGenerateGraph.clicked.connect(self.depthDrySPTGenerateGraph)
        self.pushButtondepthSPTGenerateGraph.clicked.connect(self.depthSPTGenerateGraph)
        self.pushButtonTestGraph.clicked.connect(self.generateTestsGraphs)

        # Interpolate 3d
        self.pushButtonMajority.clicked.connect(self.interpolateMajority)
        self.pushButtonIdw.clicked.connect(self.interpolateIdw)
        self.pushButtonSectionName.clicked.connect(self.createSection)
        self.pushButtonProjectPoints.clicked.connect(self.projectPoints)
        self.pushButtonGenerateSection.clicked.connect(self.generateSection)


        ############################################################################  
        #### currentIndexChanged
        ############################################################################
        self.layerAnalysisMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.field1LayerAnalysisFieldComboBox.setLayer)
        self.layerAnalysisMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.field2LayerAnalysisFieldComboBox.setLayer)
        self.layerAnalysisMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.field3LayerAnalysisFieldComboBox.setLayer)
        self.layerOneAnalysisMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.fieldOneLayerAnalysisFieldComboBox.setLayer)
        self.layerTwoAnalysisMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.fieldTwoLayerAnalysisFieldComboBox.setLayer)
        self.layerAnalysisMapLayerComboBox3d.layerChanged['QgsMapLayer*'].connect(self.fieldOneLayerAnalysisFieldComboBox3d.setLayer)
        self.layerAnalysisMapLayerComboBox3d.layerChanged['QgsMapLayer*'].connect(self.fieldTwoLayerAnalysisFieldComboBox3d.setLayer)
        self.layerAnalysisMapLayerComboBox3d.layerChanged['QgsMapLayer*'].connect(self.fieldThreeLayerAnalysisFieldComboBox3d.setLayer)
        self.layerAnalysisMapLayerComboBox3d.layerChanged['QgsMapLayer*'].connect(self.fieldFourLayerAnalysisFieldComboBox3d.setLayer)
        self.majorityMapLayerComboBox.layerChanged['QgsMapLayer*'].connect(self.majorityFieldComboBox.setLayer)
        self.mMapLayerComboBoxSection.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBoxSectionElev.setLayer)
        self.mMapLayerComboBoxSection.layerChanged['QgsMapLayer*'].connect(self.mFieldComboBoxSectionDepth.setLayer)
        


        ############################################################################  
        #### combobox
        ############################################################################


    ############################################################################  
    #### Database
    ############################################################################
    def createExtensionExecute(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.createExtension(connection)
        except Exception as error:
            print('Check function createDatabase. Cannot execute function. Reason: %s.' % (error))
        finally:
            connection.close()
    
    def dropExtensionExecute(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.dropExtension(connection)
        except Exception as error:
            print('Check function createDatabase. Cannot execute function. Reason: %s.' % (error))
        finally:
            connection.close()

    def refreshMatviewsExecute(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.refreshMatviews(connection)
        except Exception as error:
            print('Check function refreshMatviews. Cannot execute function. Reason: %s.' % (error))
    
    def executeST_Instrumentacao3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_Instrumentacao3D')
        except Exception as error:
            print('Check function executeST_Instrumentacao3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_Investigacao3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_Investigacao3D')
        except Exception as error:
            print('Check function executeST_Investigacao3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_AmostraCaixa3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_AmostraCaixa3D')
        except Exception as error:
            print('Check function executeST_AmostraCaixa3D. Cannot execute function. Reason: %s.' % (error))
    
    def executeST_AmostraCaixa3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_AmostraCaixa3D')
        except Exception as error:
            print('Check function executeST_AmostraCaixa3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_EnsaiosCampo3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_EnsaiosCampo3D')
        except Exception as error:
            print('Check function executeST_EnsaiosCampo3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_AmostraCilindro3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_AmostraCilindro3D')
        except Exception as error:
            print('Check function executeST_AmostraCilindro3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_Sondagens3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_Sondagens3D')
        except Exception as error:
            print('Check function executeST_Sondagens3D. Cannot execute function. Reason: %s.' % (error))
    
    def executeST_EnsaiosCilindro3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_EnsaiosCilindro3D')
        except Exception as error:
            print('Check function executeST_EnsaiosCilindro3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_EnsaiosCaixa3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_EnsaiosCaixa3D')
        except Exception as error:
            print('Check function executeST_EnsaiosCaixa3D. Cannot execute function. Reason: %s.' % (error))
    
    def executeST_UnidadeSolo3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_UnidadeSolo3D')
        except Exception as error:
            print('Check function executeST_UnidadeSolo3D. Cannot execute function. Reason: %s.' % (error))

    def executeST_UnidadeRocha3D(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'ST_UnidadeRocha3D')
        except Exception as error:
            print('Check function executeST_UnidadeRocha3D. Cannot execute function. Reason: %s.' % (error))
    
    def executeST_UpdateGeometrySRID(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionOneParameters(connection, 'ST_UnidadeRocha3D', self.lineEditST_UpdateGeometrySRID.displayText())
        except Exception as error:
            print('Check function executeST_UpdateGeometrySRID. Cannot execute function. Reason: %s.' % (error))

    def executeValidateSelectedGeociu(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionOneParameters(connection, 'validateSelectedGeociu', self.lineEditST_validateSelectedGeociu.displayText())
        except Exception as error:
            print('Check function executeValidateSelectedGeociu. Cannot execute function. Reason: %s.' % (error))

    def executeTurnOffKeysIndex(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'TurnOffKeysIndex')
        except Exception as error:
            print('Check function executeTurnOffKeysIndex. Cannot execute function. Reason: %s.' % (error))

    def executeTurnOnKeysIndex(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'TurnOnKeysIndex')
        except Exception as error:
            print('Check function executeTurnOnKeysIndex. Cannot execute function. Reason: %s.' % (error))

    def executeDropPermissions(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropPermissions')
        except Exception as error:
            print('Check function executeDropPermissions. Cannot execute function. Reason: %s.' % (error))

    def executeAddPermissions(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'AddPermissions')
        except Exception as error:
            print('Check function executeAddPermissions. Cannot execute function. Reason: %s.' % (error))

    def executeDropSpecificConstraints(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropSpecificConstraints')
        except Exception as error:
            print('Check function executeDropSpecificConstraints. Cannot execute function. Reason: %s.' % (error))

    def executeAddSpecificConstraints(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'AddSpecificConstraints')
        except Exception as error:
            print('Check function executeAddSpecificConstraints. Cannot execute function. Reason: %s.' % (error))

    def executeDropNotNullConstraints(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropNotNullConstraints')
        except Exception as error:
            print('Check function executeDropNotNullConstraints. Cannot execute function. Reason: %s.' % (error))

    def executeAddNotNullConstraints(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'AddNotNullConstraints')
        except Exception as error:
            print('Check function executeAddNotNullConstraints. Cannot execute function. Reason: %s.' % (error))

    def executeDropIndex(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropIndex')
        except Exception as error:
            print('Check function executeDropIndex. Cannot execute function. Reason: %s.' % (error))

    def executeCreateIndex(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'CreateIndex')
        except Exception as error:
            print('Check function executeCreateIndex. Cannot execute function. Reason: %s.' % (error))

    def executeDropGeometryIndex(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropGeometryIndex')
        except Exception as error:
            print('Check function executeDropGeometryIndex. Cannot execute function. Reason: %s.' % (error))

    def executeCreateGeometryIndex(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'CreateGeometryIndex')
        except Exception as error:
            print('Check function executeCreateGeometryIndex. Cannot execute function. Reason: %s.' % (error))

    def executeDropForeignKeys(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropForeignKeys')
        except Exception as error:
            print('Check function executeDropForeignKeys. Cannot execute function. Reason: %s.' % (error))

    def executeAddForeignKeys(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'AddForeignKeys')
        except Exception as error:
            print('Check function executeAddForeignKeys. Cannot execute function. Reason: %s.' % (error))

    def executeDropPrimaryKeys(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropPrimaryKeys')
        except Exception as error:
            print('Check function executeDropPrimaryKeys. Cannot execute function. Reason: %s.' % (error))

    def executeAddPrimaryKeys(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'AddPrimaryKeys')
        except Exception as error:
            print('Check function executeAddPrimaryKeys. Cannot execute function. Reason: %s.' % (error))

    def executeDropTriggers(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'DropTriggers')
        except Exception as error:
            print('Check function executeDropTriggers. Cannot execute function. Reason: %s.' % (error))

    def executeAddTriggers(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            dbf.executeExtensionFunctionNoParameters(connection, 'AddTriggers')
        except Exception as error:
            print('Check function executeAddTriggers. Cannot execute function. Reason: %s.' % (error))

    def calculateGrid (self):
        try: 
            layerName = self.layerAnalysisMapLayerComboBox3d.currentText()
            layer = utils.getVectorLayerByName(layerName)
            lat = self.fieldOneLayerAnalysisFieldComboBox3d.currentText()
            long = self.fieldTwoLayerAnalysisFieldComboBox3d.currentText()
            elev = self.fieldThreeLayerAnalysisFieldComboBox3d.currentText()
            var = self.fieldFourLayerAnalysisFieldComboBox3d.currentText()
            color = self.colorPlot3d.currentText()
            useSelection = self.checkSelection.isChecked()
            resultDataLat = utils.useSelectionOneVariable(layer, lat, useSelection)
            resultDataLong = utils.useSelectionOneVariable(layer, long, useSelection)
            resultDataElev = utils.useSelectionOneVariable(layer, elev, useSelection)
            resultDataVar = utils.useSelectionOneVariable(layer, var, useSelection)
            resultDataVarCk, resultDataLatCk, resultDataLongCk, resultDataElevCk = utils.checkEqualNumberFourVariables (resultDataVar, resultDataLat, resultDataLong, resultDataElev)
            step_x, step_y, step_z = self.step_x.displayText(), self.step_y.displayText(), self.step_z.displayText()
            xMax, xMin, yMax, yMin, zMax, zMin = sf.calculateGridValues (resultDataLatCk, resultDataLongCk, resultDataElevCk)
            values = [xMin, xMax, yMin, yMax, zMin, zMax]
            j = 0
            fields = [self.initial_x,  self.final_x, self.initial_y, self.final_y, self.initial_z, self.final_z]
            for field in fields:
                if field.displayText() == '':
                    field.clear()
                    field.insert(str(round(float(values[j]),2)))
                    values[j] = float(field.displayText())
                    j += 1
                else:
                    values[j] = float(field.displayText())
                    j += 1
            if self.checkPlotGrid.isChecked():
                self.clearPlot3d() 
                valores_latitude = arange(float(values[0]), float(values[1]), float(step_x))
                valores_longitude = arange(float(values[2]), float(values[3]), float(step_y))
                valores_altura = arange(float(values[4]), float(values[5]), float(step_z))
                xGrid, yGrid, zGrid = meshgrid(valores_latitude,valores_longitude,valores_altura, indexing='ij')
                elevationPlot3d, azimutePlot3d = self.elevationPlot3d.displayText(), self.azimutePlot3d.displayText()
                color = self.colorPlot3d.currentText()
                self.axes3d.clear()
                self.canvas3d.draw()
                g = self.axes3d.scatter(xGrid, yGrid, zGrid, cmap = color, s= 10, label = layerName)
                self.axes3d.set_xlabel(lat, labelpad = 10)
                self.axes3d.set_ylabel(long, labelpad = 10)
                self.axes3d.set_zlabel(elev, labelpad = 10)
                self.axes3d.legend(loc='upper left')
                cbar = self.figure3d.colorbar(g, shrink=0.5, aspect=10)
                self.axes3d.view_init(azim=int(azimutePlot3d), elev=int(elevationPlot3d))
                self.canvas3d.draw()
            if self.check_create_grid_table.isChecked():
                layerNewName = (layerName.split('.')[1]).lower()
                positions = stack((xGrid.ravel(), yGrid.ravel(), zGrid.ravel()), axis=1)
                srid = self.lineEditGridSRID.displayText()
                dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
                connectionGrid = dbf.connectDatabase(dictConnection)
                cursorGrid = connectionGrid.cursor()
                sql = ("""CREATE TABLE public.%s_grid_%s_%s_%s (grid_pk integer PRIMARY KEY, gridlatitude Numeric(10,4), gridlongitude Numeric(11,4), gridelevation Numeric(11,4), geom geometry(POINTZ,%s))""" % (layerNewName, step_x, step_y, step_z, srid))
                cursorGrid.execute(sql)
                connectionGrid.commit()
                w = 0
                entry = ''
                for point in range(len(positions)):
                    try:
                        t_id = str(int(w))
                        t_x = str(round(positions[w][0],4))
                        t_y = str(round(positions[w][1],4))
                        t_z = str(round(positions[w][2],4))
                        t_point = """ST_SetSRID(ST_MakePoint(%s,%s,%s),%s)""" % (t_x,t_y,t_z, srid)
                        entry = entry + """(%s,%s,%s,%s,%s),""" % (t_id, t_x, t_y, t_z, t_point)
                        w += 1
                    except:
                        w += 1
                        pass
                entry = entry[0:-1]
                dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.displayText(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
                connectionGridInsert = dbf.connectDatabase(dictConnection)
                cursorGridInsert = connectionGridInsert.cursor()
                sql2 = ("""INSERT INTO public.%s_grid_%s_%s_%s VALUES %s""" % (layerNewName, step_x, step_y, step_z, entry))
                cursorGridInsert.execute(sql2)
                connectionGridInsert.commit()
                sql3 = ("""CREATE INDEX %s_grid_%s_%s_%s_geom_idx  ON public.%s_grid_%s_%s_%s USING GIST (geom);""" % (layerNewName, step_x, step_y, step_z, layerNewName, step_x, step_y, step_z))
                cursorGridInsert.execute(sql3)
                connectionGridInsert.commit()
                sql4 = ("GRANT ALL ON public.%s_grid_%s_%s_%s TO %s;" % (layerNewName, step_x, step_y, step_z, self.lineEditLogin.displayText()))
                cursorGridInsert.execute(sql4)
                connectionGridInsert.commit()
                connectionGridInsert.close()
        except Exception as error:
            print('Check function calculateGrid. Cannot execute function. Reason: %s.' % (error))

    def interpolateMajority(self):
        try:
            majorityDistance = self.lineEditMajorityDistance.displayText();
            gridName = self.layerAnalysisMapLayerComboBox3d.currentText()
            layerGrid = utils.getVectorLayerByName(gridName)
            useSelection = self.checkSelection.isChecked()
            gridIds = utils.useSelectionOneVariable(layerGrid, 'grid_pk', useSelection)
            layerName = self.majorityMapLayerComboBox.currentText()
            variable = self.majorityFieldComboBox.currentText()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connectionOne = dbf.connectDatabase(dictConnection)
            connectionTwo = dbf.connectDatabase(dictConnection)
            dbf.majority(connectionOne, connectionTwo, gridIds, layerName, variable, majorityDistance, gridName)
        except Exception as error:
            print('Check function interpolateMajority. Cannot execute function. Reason: %s.' % (error))

    
    def interpolateIdw(self):
        try:
            majorityDistance = self.lineEditMajorityDistance.displayText();
            lineEditIdwNumberPoints = self.lineEditIdwNumberPoints.displayText()
            gridName = self.layerAnalysisMapLayerComboBox3d.currentText()
            layerGrid = utils.getVectorLayerByName(gridName)
            useSelection = self.checkSelection.isChecked()
            gridIds = utils.useSelectionOneVariable(layerGrid, 'grid_pk', useSelection)
            layerName = self.majorityMapLayerComboBox.currentText()
            variable = self.majorityFieldComboBox.currentText()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connectionOne = dbf.connectDatabase(dictConnection)
            connectionTwo = dbf.connectDatabase(dictConnection)
            dbf.idw(connectionOne, connectionTwo, gridIds, layerName, variable, majorityDistance, gridName, lineEditIdwNumberPoints)
        except Exception as error:
            print('Check function interpolateMajority. Cannot execute function. Reason: %s.' % (error))


    def createSection (self):
        try:
            lineEditSectionName = self.lineEditSectionName.displayText()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connectionOne = dbf.connectDatabase(dictConnection)
            cursor = connectionOne.cursor()
            cursor.execute("SELECT pggeotec.sectionsCreate('%s', '%s')" % (lineEditSectionName, dictConnection['user']))
            connectionOne.commit()
            connectionOne.close()
        except Exception as error:
            print('Check function createSection. Cannot execute function. Reason: %s.' % (error))

    def projectPoints (self):
        try:
            lineEditSectionName = self.lineEditSectionName.displayText()
            layerName = self.mMapLayerComboBoxSection.currentText()
            depth = self.mFieldComboBoxSectionDepth.currentText()
            elevation = self.mFieldComboBoxSectionElev.currentText()
            lineEditGridSRID = self.lineEditSectionSRID.displayText()
            lineEditSearchDistance = self.lineEditSearchDistance.displayText()
            lineEditInitialSection = self.lineEditInitialSection.displayText()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connectionOne = dbf.connectDatabase(dictConnection)
            cursor = connectionOne.cursor()
            if self.checkHorizontalSection.isChecked():
                cursor.execute("SELECT ic.projectPoints('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (lineEditSectionName, dictConnection['user'], layerName, depth, lineEditSearchDistance, lineEditGridSRID, lineEditInitialSection, elevation))
                connectionOne.commit()
            elif self.checkVerticalSection.isChecked():
                cursor.execute("SELECT ic.projectPointsVertical('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')" % (lineEditSectionName, dictConnection['user'], layerName, depth, lineEditSearchDistance, lineEditGridSRID, lineEditInitialSection, elevation))
                connectionOne.commit()
            else:
                pass
            connectionOne.commit()
            connectionOne.close()
        except Exception as error:
            print('Check function projectPoints. Cannot execute function. Reason: %s.' % (error))

    def generateSection (self):
        try:
            lineEditSectionName = self.lineEditSectionName.displayText()
            layerName = '%s_poly' % (lineEditSectionName)
            layerSection = utils.getVectorLayerByName(layerName)
            resultDataPk, resultDataClass = utils.recoverTwoVariable(layerSection, 'sg_pk', 'sg_class')
            #resultDataClass = utils.recoverOneVariable(layerSection, 'sg_class')
            lineEditGridSRID = self.lineEditSectionSRID.displayText()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connectionOne = dbf.connectDatabase(dictConnection)
            cursor = connectionOne.cursor()
            i = 0
            for pk in resultDataPk:
                if self.checkHorizontalSection.isChecked():
                    # pggeotec.generate3dSectionVertical(sectionName text, currentUser text, sgClass text, sgPk text, srid text)
                    cursor.execute("SELECT ic.generate3dSectionHorizontal('%s', '%s', '%s', '%s', '%s')" % (lineEditSectionName, dictConnection['user'], str(resultDataClass[i]), str(pk), lineEditGridSRID))
                    print("SELECT ic.generate3dSectionHorizontal('%s', '%s', '%s', '%s', '%s')" % (lineEditSectionName, dictConnection['user'], str(resultDataClass[i]), str(pk), lineEditGridSRID))
                    connectionOne.commit()
                    i += 1
                elif self.checkVerticalSection.isChecked():
                    cursor.execute("SELECT ic.generate3dSectionVertical('%s', '%s', '%s', '%s', '%s')" % (lineEditSectionName, dictConnection['user'], str(resultDataClass[i]), str(pk), lineEditGridSRID))
                    print("SELECT ic.generate3dSectionVertical('%s', '%s', '%s', '%s', '%s')" % (lineEditSectionName, dictConnection['user'], str(resultDataClass[i]), str(pk), lineEditGridSRID))
                    connectionOne.commit()
                    i += 1
                else:
                    i += 1
            connectionOne.commit()
            connectionOne.close()
        except Exception as error:
            print('Check function projectPoints. Cannot execute function. Reason: %s.' % (error))


    ############################################################################
    #### Combobox
    ############################################################################
    def configureDomain(self):
        try:
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            query = ("SELECT esquema, tabela, coluna, tab_dom, chave_tb_dom, col_tb_dom FROM dom.tb_dom_controle WHERE tabela = '%s'" % (table))
            dataframe = read_sql_query(query, connection)
            for row in range(dataframe.shape[0]):
                 utils.recuperarDominios (connection, dataframe.loc[row,'chave_tb_dom'], dataframe.loc[row,'col_tb_dom'], dataframe.loc[row,'tab_dom'], dataframe.loc[row,'tabela'], dataframe.loc[row,'coluna'])
            connection.commit()
        except Exception as error:
            print('Check function configureDomain. Cannot execute function. Reason: %s.' % (error))

    def colorTypes (self):
        try:
            lista = ['viridis', 'plasma', 'inferno', 'magma', 'cividis','Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds','YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
                    'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn','flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix',
                     'brg', 'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar','Pastel1', 'Pastel2', 'Paired', 'Accent','Dark2', 'Set1', 'Set2', 'Set3','tab10', 'tab20', 
                     'tab20b', 'tab20c', 'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu','RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic','binary', 'gist_yarg', 'gist_gray',
                      'gray', 'bone', 'pink','spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia','hot', 'afmhot', 'gist_heat', 'copper']
            self.colorPlot3d.clear()
            self.colorPlot3d.addItems(lista)
        except Exception as error:
            print('Check function colorTypes. Cannot execute function. Reason %s' %(error))

    ############################################################################
    #### Checks
    ############################################################################
    def checkVertical(self):
        if self.checkVerticalSection.isChecked():
            self.checkHorizontalSection.setChecked(False)

    def checkHorizontal(self):
        if self.checkHorizontalSection.isChecked():
            self.checkVerticalSection.setChecked(False)

    ############################################################################
    #### Graphs
    ############################################################################
    def figurePlot(self):
        self.figure = pyplot.Figure()
        self.axes = self.figure.add_subplot(111)
        self.canvas = FigureCanvas(self.figure)
        self.mpltoolbar = NavigationToolbar(self.canvas, self.widgetPlot)
        lstActions = self.mpltoolbar.actions()
        self.mpltoolbar.removeAction(lstActions[7])
        self.layoutPlot.addWidget(self.canvas)
        self.layoutPlot.addWidget(self.mpltoolbar)

    def figure3dPlot(self):
        self.figure3d = pyplot.Figure()
        self.axes3d = self.figure3d.add_subplot(111, projection='3d')
        self.canvas3d = FigureCanvas(self.figure3d)
        self.mpltoolbar3d = NavigationToolbar(self.canvas3d, self.widgetPlot3d)
        lstActions3d = self.mpltoolbar3d.actions()
        self.mpltoolbar3d.removeAction(lstActions3d[7])
        self.layoutPlot3d.addWidget(self.canvas3d)
        self.layoutPlot3d.addWidget(self.mpltoolbar3d)
        self.axes3d.set_title(self.tr(" "))

    def configureBins(self, resultData):
        try:
            if self.checkBin.isChecked():
                numberBins = int(self.lineEditBinNumber.displayText())
            else:
                resultDataCount = len(resultData)
                numberBins = int(float(1) + float(3.222)*log(resultDataCount))
            return numberBins
        except Exception as error:
            print('Check function configurePlot. Cannot execute function. Reason: %s.' % (error))

    def histogram(self):
        try:
            self.clearPlot()
            layer = utils.getVectorLayerByName(self.layerAnalysisMapLayerComboBox.currentText())
            fieldName = self.field1LayerAnalysisFieldComboBox.currentText()
            useSelection = self.checkSelection.isChecked()
            resultData = utils.useSelectionOneVariable(layer, fieldName, useSelection)
            numberBins = self.configureBins(resultData)
            self.axes.set_title(self.tr('Histogram of %s' %(fieldName)))
            self.axes.grid(self.checkShowGrid.isChecked())
            self.axes.set_xlabel(str(fieldName))
            self.axes.axes.hist(resultData, bins = numberBins, label = 'Values of %s' % (fieldName))
            self.axes.set_ylabel('Frequency')
            self.axes.legend()
            self.canvas.draw()
        except Exception as error:
            print('Check function histogram. Cannot execute function. Reason: %s.' % (error))
    
    def recoverData(self):
        try:
            layer = utils.getVectorLayerByName(self.layerAnalysisMapLayerComboBox.currentText())
            fieldName = self.field1LayerAnalysisFieldComboBox.currentText()
            useSelection = self.checkSelection.isChecked()
            return layer, fieldName, useSelection
        except Exception as error:
            print('Check function recoverData. Cannot execute function. Reason: %s.' % (error))
    
    def recoverDataTwoVariables(self):
        try:
            layer = utils.getVectorLayerByName(self.layerAnalysisMapLayerComboBox.currentText())
            fieldName1 = self.field1LayerAnalysisFieldComboBox.currentText()
            fieldName2 = self.field2LayerAnalysisFieldComboBox.currentText()
            useSelection = self.checkSelection.isChecked()
            return layer, fieldName1, fieldName2, useSelection
        except Exception as error:
            print('Check function recoverDataTwoVariables. Cannot execute function. Reason: %s.' % (error))

    def recoverDataThreeVariables(self):
        try:
            layer = utils.getVectorLayerByName(self.layerAnalysisMapLayerComboBox.currentText())
            fieldName1 = self.field1LayerAnalysisFieldComboBox.currentText()
            fieldName2 = self.field2LayerAnalysisFieldComboBox.currentText()
            fieldName3 = self.field3LayerAnalysisFieldComboBox.currentText()
            useSelection = self.checkSelection.isChecked()
            return layer, fieldName1, fieldName2, fieldName3, useSelection
        except Exception as error:
            print('Check function recoverDataThreeVariables. Cannot execute function. Reason: %s.' % (error))

    def statistics(self):
        try:
            layer, fieldName, useSelection = self.recoverData()
            statistics = sf.statisticsDescritive(layer, fieldName, useSelection)
            print(statistics)
        except Exception as error:
            print('Check function histogram. Cannot execute function. Reason: %s.' % (error))

    def scatterPlot(self):
        try:
            self.clearPlot()
            layer = utils.getVectorLayerByName(self.layerAnalysisMapLayerComboBox.currentText())
            fieldName1 = self.field1LayerAnalysisFieldComboBox.currentText()
            fieldName2 = self.field2LayerAnalysisFieldComboBox.currentText()
            useSelection = self.checkSelection.isChecked()
            statistics1, statistics2, resultDataOne, resultDataTwo = sf.correlationAnalysis(layer, fieldName1, fieldName2, useSelection)
            print('%s - %s' % (fieldName1, statistics1))
            print('%s - %s' % (fieldName2, statistics2))
            self.axes.set_title(self.tr('Scatterplot of %s and %s' % (fieldName1, fieldName2)))
            self.axes.grid(self.checkShowGrid.isChecked())
            self.axes.set_xlabel(str(fieldName1))
            self.axes.set_ylabel(str(fieldName2))
            self.axes.plot(resultDataOne, resultDataTwo, "go")
            self.figure.autofmt_xdate()
            self.canvas.draw()
        except Exception as error:
            print('Check function scatterPlot. Cannot execute function. Reason: %s.' % (error))

    def boxPlot(self):
        try:
            self.clearPlot()
            layer, fieldName, useSelection = self.recoverData()
            resultData = utils.useSelectionOneVariable(layer, fieldName, useSelection)
            self.axes.axes.boxplot(resultData, notch= True, bootstrap = 10000)
            self.axes.set_title(self.tr('BoxPlot of %s.' % (fieldName)))
            self.axes.grid(self.checkShowGrid.isChecked())
            self.axes.set_ylabel('Values of %s' % (fieldName))
            self.axes.set_xlabel('%s' % (fieldName))
            self.figure.autofmt_xdate()
            self.canvas.draw()
        except Exception as error:
            print('Check function boxPlot. Cannot execute function. Reason: %s.' % (error))

    def qqPlot(self):
        try:
            self.clearPlot()
            layer, fieldName, useSelection = self.recoverData()
            posx, posy, osm , osr, slope, intercept, r = sf.qqPlotData(layer, fieldName, useSelection)
            self.axes.plot(osm, osr, 'o')
            self.axes.plot(osm, slope*osm + intercept, 'r-',  label = fieldName)
            self.axes.legend()
            self.axes.set_title(self.tr('q-q Plot of %s' % (fieldName)))
            self.axes.grid(self.checkShowGrid.isChecked())
            self.axes.set_ylabel('Ordered Values (data sample)')
            self.axes.set_xlabel('Quantiles of Normal Distribution ')
            self.axes.text(posx, posy, "R^2=%1.4f" % r)
            self.figure.autofmt_xdate()
            self.canvas.draw()
        except Exception as error:
            print('Check function qqPlot. Cannot execute function. Reason: %s.' % (error))
    
    def ecdfPlot(self):
        try:
            self.clearPlot()
            layer, fieldName, useSelection = self.recoverData()
            x, y = sf.ecdfData(layer, fieldName, useSelection)
            self.axes.plot(x, y, '--', label = fieldName)
            self.axes.legend()
            self.axes.set_title(self.tr('ECDF of %s' % (fieldName)))
            self.axes.grid(self.checkShowGrid.isChecked())
            self.axes.set_ylabel('Cumulative probability')
            self.axes.set_xlabel('Values of %s' % (fieldName))
            self.figure.autofmt_xdate()
            self.canvas.draw()
        except Exception as error:
            print('Check function ecdfPlot. Cannot execute function. Reason: %s.' % (error))
    
    def multiplePlot(self):
        try:
            self.clearPlot()
            layerOne = utils.getVectorLayerByName(self.layerOneAnalysisMapLayerComboBox.currentText())
            fieldNameOne = self.fieldOneLayerAnalysisFieldComboBox.currentText()
            useSelection = self.checkSelection.isChecked()
            layerTwo = utils.getVectorLayerByName(self.layerTwoAnalysisMapLayerComboBox.currentText())
            fieldNameTwo = self.fieldTwoLayerAnalysisFieldComboBox.currentText()
            resultDataOne = utils.useSelectionOneVariable(layerOne, fieldNameOne, useSelection)
            resultDataTwo = utils.useSelectionOneVariable(layerTwo, fieldNameTwo, useSelection)
            self.canvas.draw()
            self.axes.set_title(self.tr("Frequency histogram"))
            self.axes.grid(self.checkShowGrid.isChecked())
            self.axes.set_ylabel('Frequency')
            if self.checkBin.isChecked():
                numberBinOne = int(self.lineEditBinNumber.displayText())
                numberBinTwo = int(self.lineEditBinNumber.displayText())
            else:
                numberBinOne = int(float(1.0) + float(3.222)*log(len(resultDataOne)))
                numberBinTwo = int(float(1.0) + float(3.222)*log(len(resultDataTwo)))
            self.axes.axes.hist(resultDataOne, histtype = 'step', bins = numberBinOne, label = '%s' % (fieldNameOne), color = 'red')
            self.axes.axes.hist(resultDataTwo, histtype = 'step',bins = numberBinTwo, label = '%s' % (fieldNameTwo), color = 'blue')
            self.axes.legend()
        except Exception as error:
            print('Check function multiplePlot. Cannot execute function. Reason: %s.' % (error))
    
    def generateTestsGraphs(self):
        try:
            self.clearPlot()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            identifier = self.identifier.displayText()
            if 'AD' in identifier:
                variable_one, variable_two = dbf.consolidationGenerateData(connection, identifier)
                self.axes.plot(variable_one, variable_two,"rs-", color='red', label = str(identifier))
                self.axes.set_title('e vs Presure')
                self.axes.set_xscale('log')
                self.axes.set_ylabel('e')
                self.axes.set_xlabel('Pressure')
                self.axes.grid(which="both", ls="-", color='0.65')
                self.axes.legend(loc = 1)
            elif 'G' in identifier:  # x em log
                variable_one, variable_two, g_teor_finos, g_teor_gro, g_diam_efet, g_coef_unif, g_coef_curv, g_defloc = dbf.granulometryGenerateData(connection, identifier)
                self.axes.plot(variable_one, variable_two,"rs-", color='red', label = str(identifier))
                self.axes.set_xscale('log')
                self.axes.set_ylabel('Percentage pass')
                self.axes.set_xlabel('Particule size')
                self.axes.axvline(g_teor_finos, linestyle='--', color = 'blue', label = 'Fines content: %s'% (str(round(g_teor_finos,2))))
                self.axes.axvline(g_teor_gro, linestyle='--', color = 'green', label = 'Coarse content: %s'% (str(round(g_teor_gro,2))))
                self.axes.axvline(g_diam_efet, linestyle='--', color = 'yellow', label = 'Effective diameter: %s'% (str(round(g_diam_efet,4))))
                self.axes.axvline(g_coef_unif, linestyle='--', color = 'orange', label = 'Coefficient of uniformity: %s'% (str(round(g_coef_unif,4))))
                self.axes.axvline(g_coef_curv, linestyle='--', color = 'black', label = 'Coefficient of curvature: %s'% (str(round(g_coef_curv,4))))
                self.figure.autofmt_xdate()
                self.axes.set_title('Particule Size vs Percentage (%s)' % (g_defloc))
                self.axes.set_yticks(arange(0, 110, 10))
                self.axes.grid(which="both", ls="-", color='0.65')
                self.axes.legend(loc = 2)
            elif 'LA' in identifier:
                if self.chech_use_eda_la.isChecked() == False:
                    dataframe = dbf.atterberbGenerateData(connection, identifier)
                    self.axes.plot(dataframe.loc[0,'la_limit_liq'], dataframe.loc[0,'la_ind_plast'],"*", color='red', label = str(identifier))
                else:
                    layerOne = utils.getVectorLayerByName(self.layerOneAnalysisMapLayerComboBox.currentText())
                    fieldNameOne = self.fieldOneLayerAnalysisFieldComboBox.currentText()
                    useSelection = self.checkSelection.isChecked()
                    layerTwo = utils.getVectorLayerByName(self.layerTwoAnalysisMapLayerComboBox.currentText())
                    fieldNameTwo = self.fieldTwoLayerAnalysisFieldComboBox.currentText()
                    resultDataOne = utils.useSelectionOneVariable(layerOne, fieldNameOne, useSelection)
                    resultDataTwo = utils.useSelectionOneVariable(layerTwo, fieldNameTwo, useSelection)
                    result_data_one_new, result_data_two_new = utils.checkEqualNumberTwoVariables (resultDataOne, resultDataTwo)
                    self.axes.plot(result_data_one_new, result_data_two_new,"*", color='red', label = 'EDA samples')
                self.axes.set_ylabel('Plasticity index (%)')
                self.axes.set_xlabel('Liquid limit (%)')
                self.axes.set_yticks(arange(0, 110, 10))
                self.axes.set_xticks(arange(0, 110, 10))
                self.axes.set_title('Liquid limit vs Plasticity index (%s)' % (identifier))
                self.axes.grid(which="both", ls="-", color='0.65')
                self.axes.axvline(50, linestyle='--', color = 'black')
                self.axes.axvline(30, linestyle='--', color = 'black')
                self.axes.plot([20,100], [0, 58.4],"-", color='blue', label = 'Linha A - IP = 0,73(LL-20)')
                self.axes.plot([8,75], [0, 60.3],"-", color='green', label = 'Linha U - IP = 0,90(LL-8)')
                self.axes.text(42, 5, 'OL')
                self.axes.text(35, 27, 'CL')
                self.axes.text(35, 5, 'ML')
                self.axes.text(53, 14, 'MH')
                self.axes.text(53, 35, 'CH')
                self.axes.text(33, 14, 'OH')
                self.axes.legend(loc = 2)
            elif 'ISC' in identifier:
                dataframe = dbf.iscGenerateData(connection, identifier)
                self.axes.plot(dataframe.loc[:,'iscm_penet'], dataframe.loc[:,'iscm_pressao'],"rs-", color='red', label = str(identifier))
                self.axes.set_title('Pressure vs Penetration (%s)' % (identifier))
                self.axes.grid(which="both", ls="-", color='0.65')
                self.axes.legend(loc = 2)
                self.axes.set_ylabel('Pressure (MPa)')
                self.axes.set_xlabel('Penetration (mm)')
            elif 'CP' in identifier:
                dataframe = dbf.compactacGenerateData(connection, identifier)
                self.axes.plot(dataframe.loc[:,'cm_umid_med'], dataframe.loc[:,'cm_densidade'],"rs-", color='red', label = str(identifier))
                self.axes.set_title('Specifc weight vs moisture (%s)' % (identifier))
                self.axes.grid(which="both", ls="-", color='0.65')
                self.axes.legend(loc = 2)
                self.axes.set_ylabel('Specifc weight (kN/m³)')
                self.axes.set_xlabel('Moisture (%)')
                pass
            elif 'CD' in identifier:
                pass
            elif 'TR' in identifier:
                pass
            elif 'PZ' in identifier:
                dataframe, dataframe_chuvoso, dataframe_seco = dbf.piezometerGenerateData(connection, identifier)
                self.axes.plot(dataframe.loc[:,'pz_data_med'], dataframe.loc[:,'pz_na_med'],"rs-", color='blue', label = str(identifier))
                self.axes.set_title('Historical measure of water depth (%s)' % (identifier))               
                self.axes.grid(which="both", ls="-", color='0.65')
                min_value, max_value, med_value, median_value = amin(dataframe.loc[:,'pz_na_med']), amax(dataframe.loc[:,'pz_na_med']), round(mean(dataframe.loc[:,'pz_na_med']),2), round(median(dataframe.loc[:,'pz_na_med']),2)
                med_value_chuvoso, median_value_chuvoso = round(mean(dataframe_chuvoso.loc[:,'pz_na_med']),2), round(median(dataframe_chuvoso.loc[:,'pz_na_med']),2)
                med_value_seco, median_value_seco = round(mean(dataframe_seco.loc[:,'pz_na_med']),2), round(median(dataframe_seco.loc[:,'pz_na_med']),2)
                self.axes.axhline(med_value, linestyle='--', color = 'black', label = 'Mean: %s' % (str(med_value)))
                self.axes.axhline(median_value, linestyle='--', color = 'red', label = 'Median: %s' % (str(median_value)))
                self.axes.axhline(med_value_chuvoso, linestyle='--', color = 'yellow', label = 'Mean(Wet period): %s' % (str(med_value)))
                self.axes.axhline(median_value_chuvoso, linestyle='--', color = 'green', label = 'Median(Wet period): %s' % (str(median_value)))
                self.axes.axhline(med_value_seco, linestyle='--', color = 'pink', label = 'Mean(Dry period): %s' % (str(med_value)))
                self.axes.axhline(median_value_seco, linestyle='--', color = 'purple', label = 'Median(Dry period): %s' % (str(median_value)))
                self.axes.legend(loc = 1)
                self.axes.set_ylabel('Water depth (m)')
                self.axes.set_xlabel('Date')
                self.axes.set_yticks(arange(min_value-1, max_value+1, 0.5))
                self.axes.invert_yaxis()
            self.canvas.draw()
            connection.close()
        except Exception as error:
            print('Check function multiplePlot. Cannot execute function. Reason: %s.' % (error))

    def depthWetSPTGenerateGraph(self):
        try:
            self.clearPlot()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            profund, minimo, q1, mediano, media, q3, maximo = dbf.depthWetSPTGenerateData(connection)
            self.axes.plot(minimo,profund,"rs-", color='black', label = 'Minimum')
            self.axes.plot(q1,profund,"rs-", color='blue', label = 'Lower Quartile')
            self.axes.plot(media,profund,"rs-", color='green', label = 'Mean')
            self.axes.plot(mediano,profund,"rs-", color='yellow', label = 'Median')
            self.axes.plot(q3,profund,"rs-", color='orange', label = 'Upper Quartile')
            self.axes.plot(maximo,profund,"rs-", color='red', label = 'Maximum')
            self.axes.set_ylabel('Depth (m)')
            self.axes.set_xlabel('Number of hits - SPT')
            self.axes.legend(loc = 1)
            self.axes.invert_yaxis()
            self.canvas.draw()
            connection.close()
        except Exception as error:
            print('Check function depthWetSPTGenerateGraph. Cannot execute function. Reason: %s.' % (error))

    def depthDrySPTGenerateGraph(self):
        try:
            self.clearPlot()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            profund, minimo, q1, mediano, media, q3, maximo = dbf.depthDrySPTGenerateData(connection)
            self.axes.plot(minimo,profund,"rs-", color='black', label = 'Minimum')
            self.axes.plot(q1,profund,"rs-", color='blue', label = 'Lower Quartile')
            self.axes.plot(media,profund,"rs-", color='green', label = 'Mean')
            self.axes.plot(mediano,profund,"rs-", color='yellow', label = 'Median')
            self.axes.plot(q3,profund,"rs-", color='orange', label = 'Upper Quartile')
            self.axes.plot(maximo,profund,"rs-", color='red', label = 'Maximum')
            self.axes.set_ylabel('Depth (m)')
            self.axes.set_xlabel('Number of hits - SPT')
            self.axes.legend(loc = 1)
            self.axes.invert_yaxis()
            self.canvas.draw()
            connection.close()
        except Exception as error:
            print('Check function depthDrySPTGenerateData. Cannot execute function. Reason: %s.' % (error))
    
    def depthSPTGenerateGraph(self):
        try:
            self.clearPlot()
            dictConnection = {'user':self.lineEditLogin.displayText(), 'password':self.LineEditPassword.text(), 'host':self.lineEditLocalhost.displayText(), 'port':self.lineEditPort.displayText(), 'name':self.lineEditDatabase.displayText()}
            connection = dbf.connectDatabase(dictConnection)
            profund, minimo, q1, mediano, media, q3, maximo = dbf.depthSPTGenerateData(connection)
            self.axes.plot(minimo,profund,"rs-", color='black', label = 'Minimum')
            self.axes.plot(q1,profund,"rs-", color='blue', label = 'Lower Quartile')
            self.axes.plot(media,profund,"rs-", color='green', label = 'Mean')
            self.axes.plot(mediano,profund,"rs-", color='yellow', label = 'Median')
            self.axes.plot(q3,profund,"rs-", color='orange', label = 'Upper Quartile')
            self.axes.plot(maximo,profund,"rs-", color='red', label = 'Maximum')
            self.axes.set_ylabel('Depth (m)')
            self.axes.set_xlabel('Number of hits - SPT')
            self.axes.legend(loc = 1)
            self.axes.invert_yaxis()
            self.canvas.draw()
            connection.close()
        except Exception as error:
            print('Check function depthSPTGenerateGraph. Cannot execute function. Reason: %s.' % (error))

    def plot3d(self):
        try:
            self.clearPlot3d()
            elevationPlot3d = self.elevationPlot3d.displayText()
            azimutePlot3d = self.azimutePlot3d.displayText()
            layerName = self.layerAnalysisMapLayerComboBox3d.currentText()
            layer = utils.getVectorLayerByName(layerName)
            lat = self.fieldOneLayerAnalysisFieldComboBox3d.currentText()
            long = self.fieldTwoLayerAnalysisFieldComboBox3d.currentText()
            elev = self.fieldThreeLayerAnalysisFieldComboBox3d.currentText()
            var = self.fieldFourLayerAnalysisFieldComboBox3d.currentText()
            color = self.colorPlot3d.currentText()
            useSelection = self.checkSelection.isChecked()
            resultDataLat = utils.useSelectionOneVariable(layer, lat, useSelection)
            resultDataLong = utils.useSelectionOneVariable(layer, long, useSelection)
            resultDataElev = utils.useSelectionOneVariable(layer, elev, useSelection)
            resultDataVar = utils.useSelectionOneVariable(layer, var, useSelection)
            resultDataVarCk, resultDataLatCk, resultDataLongCk, resultDataElevCk = utils.checkEqualNumberFourVariables (resultDataVar, resultDataLat, resultDataLong, resultDataElev)
            matrix = zeros((len(resultDataVarCk), 4))
            i = 0
            for element in resultDataVarCk:
                try:
                    matrix[i][0], matrix[i][1], matrix[i][2], matrix[i][3] = float(resultDataLatCk[i]), float(resultDataLongCk[i]), float(resultDataElevCk[i]), float(element)
                    i += 1
                except ValueError as error:
                    print('Check function dialog.plot_3d. Maybe imput is not a number. Reason %s' % (error))
                    i += 1
            cmapp = color 
            c, s = matrix[:,3], matrix[:,3]   
            self.axes3d.clear()
            self.canvas3d.draw()
            g = self.axes3d.scatter(matrix[:, 0], matrix[:, 1], matrix[:, 2], cmap = cmapp, c = c, s= 10, label = layerName)
            self.axes3d.set_xlabel(lat, labelpad = 10)
            self.axes3d.set_ylabel(long, labelpad = 10)
            self.axes3d.set_zlabel(elev, labelpad = 10)
            self.axes3d.legend(loc='upper left')
            cbar = self.figure3d.colorbar(g, shrink=0.5, aspect=10)
            self.axes3d.view_init(azim=int(azimutePlot3d), elev=int(elevationPlot3d))
            self.canvas3d.draw()
        except (Exception) as error:
            print('Check function plot_3d. Cannot execute function. Reason %s' % (error))

    def axesAddGrid(self):
        try:
            self.axes.grid(self.checkShowGrid.isChecked())
        except Exception as error:
            print('Check function axesAddGrid. Cannot execute function. Reason: %s.' % (error))

    def clearPlot(self):
        try:
            self.figure.clf()
            self.axes = self.figure.add_subplot(111)
            self.axes.clear()
            self.axes.axes.clear()
            self.canvas.draw()
        except Exception as error:
            print ('Check function clearPlot. Cannot execute function. Reason: %s.' % (error))

    def clearPlot3d(self):
        try:
            self.figure3d.clf()
            self.axes3d = self.figure3d.add_subplot(111, projection='3d')
            self.axes3d.clear()
            self.canvas3d.draw()
        except Exception as error:
            print('Check function clearPlot3d. Cannot execute function. Reason: %s.' % (error))

        
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
