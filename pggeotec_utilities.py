# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeotecnicalDataExplorer
                                 A QGIS plugin
 Allow to explore data from the geotechnical database model

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-02-26
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Bruno Rodrigues
        email                : brunorodriguesoli@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import *
from qgis.gui import *
from qgis.utils import *

############################################################################################################################################################################################
# QGIS Methods                                                                       
############################################################################################################################################################################################
class utilsFunctions:
    
    def getVectorLayerNames():
        try:
            layerMap =  QgsProject.instance().mapLayers()
            layerNames = []
            for name, layer in layerMap.items():
                if layer.type() == QgsMapLayer.VectorLayer:
                    layerNames.append(str(layer.name()))
            return sorted(layerNames)
        except Exception as error:
            if (isinstance(error, object)) == False:
                print(f'Check function utils.getVectorLayerNames. Cannot execute function. Reason {error}')
        

    def getVectorLayerByName(layerName):
        try:
            layerMap =  QgsProject.instance().mapLayers()
            for name, layer in layerMap.items():
                if layer.type() == QgsMapLayer.VectorLayer and layer.name() == layerName:
                    if layer.isValid():
                        return layer
                    else:
                        return None
        except Exception as error:
            if (isinstance(error, object)) == False:
                print(f'Check function utils.getVectorLayerByName. Cannot execute function. Reason {error}')

    def getRasterLayerByName(layerName):
        try:
            layerMap =  QgsProject.instance().mapLayers()
            for name, layer in layerMap.items():
                if layer.type() == QgsMapLayer.RasterLayer and layer.name() == layerName:
                    if layer.isValid():
                        return layer
                    else:
                        return None
        except Exception as error:
            print(f'Check getRasterLayerByName. Reason {error}')

    def getFieldNames(layer, fieldTypes):
        try:
            fields = layer.fields()
            fieldNames = []
            for field in fields:
                if field.type() in fieldTypes and not field.name() in fieldNames:
                    fieldNames.append(str(field.name()))
            return sorted(fieldNames)
        except Exception as error:
            if (isinstance(error, object)) == False:
                print(f'Check function utils.getFieldNames. Cannot execute function. Reason {error}') 

    def getFieldType(layer, fieldName):
        try:
            fields = layer.fields()
            for field in fields:
                if field.name() == fieldName:
                    return field.typeName()
        except Exception as error:
            if (isinstance(error, object)) == False:
                print(f'Check function utils.getFieldType. Cannot execute function. Reason {error}')

    def getUniqueValuesCount(layer, fieldIndex, useSelection):
        try:
            count = 0
            values = []
            if useSelection:
                for f in layer.selectedFeatures():
                    if f[fieldIndex] not in values:
                        values.append(f[fieldIndex])
                        count += 1
            else:
                request = QgsFeatureRequest().setFlags(QgsFeatureRequest.NoGeometry)
                for f in layer.getFeatures(request):
                    if f[fieldIndex] not in values:
                        values.append(f[fieldIndex])
                        count += 1
            return count
        except Exception as error:
            print(f'Check getUniqueValuesCount. Reason {error}')

    
    ############################################################################################################################################################################################
    # Tratar vari√°veis                                                                      
    ############################################################################################################################################################################################
    
    def recoverOneVariable(layer, fieldName):
        try:
            index = layer.fields().indexFromName(fieldName)
            request = QgsFeatureRequest()
            request.setFlags(QgsFeatureRequest.NoGeometry)
            request.setSubsetOfAttributes([index])
            sdata = []
            for f in layer.getFeatures():
                if f[index]:
                    stemp = f[index]
                else:
                    stemp = None
                sdata.append(stemp)
            return sdata
        except Exception as error:
            print('Check recoverOneVariable. Cannot use selection. Reason %s' % (error))
    
    def recoverTwoVariable(layer, fieldName, fieldNametwo):
        try:
            index = layer.fields().indexFromName(fieldName)
            request = QgsFeatureRequest()
            request.setFlags(QgsFeatureRequest.NoGeometry)
            request.setSubsetOfAttributes([index])
            index2 = layer.fields().indexFromName(fieldNametwo)
            request2 = QgsFeatureRequest()
            request2.setFlags(QgsFeatureRequest.NoGeometry)
            request2.setSubsetOfAttributes([index])
            sdata = []
            sdata2 = []
            for f in layer.getFeatures():
                if f[index]:
                    stemp = f[index]
                    stemp2 = f[index2]
                else:
                    pass
                sdata.append(stemp)
                sdata2.append(stemp2)
            return sdata, sdata2
        except Exception as error:
            print('Check recoverOneVariable. Cannot use selection. Reason %s' % (error))

    def useSelectionOneVariable(layer, fieldName, useSelection):
        try:
            index = layer.fields().indexFromName(fieldName)
            request = QgsFeatureRequest()
            request.setFlags(QgsFeatureRequest.NoGeometry)
            request.setSubsetOfAttributes([index])
            sdata = []
            result_data = []
            if useSelection:
                for f in layer.selectedFeatures() :
                    if f[index]:
                        stemp = float(f[index])
                    else:
                        stemp = None
                    sdata.append(stemp)
            else:
                for f in layer.getFeatures():
                    if f[index]:
                        stemp = float(f[index])
                    else:
                        stemp = None
                    sdata.append(stemp)
            for element in sdata:
                if (element is not None):
                    result_data.append(element)
            return result_data
        except Exception as error:
            print('Check useSelectionOneVariable. Cannot use selection. Reason %s' % (error))

    def checkEqualNumberTwoVariables(variableOne, variableTwo):
        try:
            resultDataVarOne = []
            resultDataVarTwo = []
            z = 0 - 1
            for element in variableOne:
                z += 1
                if (z <= len(variableOne)) and (z <= len(variableTwo)):
                    if  (variableOne[z] is not None) and (variableTwo[z] is not None):
                        resultDataVarOne.append(variableOne[z])
                        resultDataVarTwo.append(variableTwo[z])
                else:
                    pass
            return resultDataVarOne, resultDataVarTwo
        except Exception as error:
            print('Check checkEqualNumberTwoVariables. Cannot use selection. Reason %s' % (error))
    
    def checkEqualNumberThreeVariables (variable_one, variable_two, variable_three):
        try:
            [result_data_variable_one, result_data_variable_two, result_data_variable_three] = [[],[],[]]
            z = 0 - 1
            for element_before in variable_one:
                z += 1
                if (z <= len(variable_one)) and (z <= len(variable_two)) and (z <= len(variable_three)):
                    if  (variable_one[z] is not None) and (variable_two[z] is not None) and (variable_three[z] is not None):
                        result_data_variable_one.append(variable_one[z])
                        result_data_variable_two.append(variable_two[z])
                        result_data_variable_three.append(variable_three[z])
                else:
                    pass
            return result_data_variable_one, result_data_variable_two, result_data_variable_three
        except Exception as error:
            print('Check checkEqualNumberTwoVariables. Cannot use selection. Reason %s' % (error))
    
    def checkEqualNumberFourVariables (variable_one, variable_two, variable_three, variable_four):
        try:
            [result_data_variable_one, result_data_variable_two, result_data_variable_three, result_data_variable_four] = [[],[],[],[]]
            z = 0 - 1
            for element_before in variable_one:
                z += 1
                if (z < len(variable_one)) and (z < len(variable_two)) and (z < len(variable_three)) and (z < len(variable_four)):
                    if  (variable_one[z] is not None) and (variable_two[z] is not None) and (variable_three[z] is not None) and (variable_four[z] is not None):
                        result_data_variable_one.append(variable_one[z])
                        result_data_variable_two.append(variable_two[z])
                        result_data_variable_three.append(variable_three[z])
                        result_data_variable_four.append(variable_four[z])
                else:
                    pass
            return result_data_variable_one, result_data_variable_two, result_data_variable_three, result_data_variable_four
        except Exception as error:
            print('Check checkEqualNumberFourVariables. Cannot use selection. Reason %s' % (error))  
