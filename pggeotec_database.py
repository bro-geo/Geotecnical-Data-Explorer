# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeotecnicalDataExplorer
                                 A QGIS plugin
 Allow to explore data from the geotechnical database model

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-02-26
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Bruno Rodrigues
        email                : brunorodriguesoli@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import psycopg2

from pandas import read_sql_query


class databaseFunctions: 
############################################################################################################################################################################################
# User methods                                                                       
############################################################################################################################################################################################
    def connectDatabase(dictConnection):
        """Connect to the PostgreSQL database.
            :param dictConnection: Dictionary {'user': User, 'password': Password, 'host': Host, 'port':Port, 'name':Database name}
			:return: Instance of connection with the database
		"""
        try:
            connection = psycopg2.connect(user = dictConnection['user'], password = dictConnection['password'], host = dictConnection['host'], port = dictConnection['port'], database = dictConnection['name'])
            return connection
        except (Exception, psycopg2.Error) as error :
            print('Check function databaseFunctions.connectDatabase. Cannot execute function. Reason %s.' % (error)) 
    
    def createExtension(connection):
        """Create pggeotec extension and dependencies in PostgreSQL database.
            :param connection: Instance of connection with the database
			:return: No return
		"""
        try:
            cursor = connection.cursor()
            sql = {'postgis': 'CREATE EXTENSION IF NOT EXISTS postgis;', 'sfcgal':'CREATE EXTENSION IF NOT EXISTS postgis_sfcgal;', 'pggeotec': 'CREATE EXTENSION IF NOT EXISTS pggeotec;'}
            cursor.execute(sql['postgis'])
            connection.commit()
            cursor.execute(sql['sfcgal'])
            connection.commit()
            cursor.execute(sql['pggeotec'])
            connection.commit()
            print('Extension created.')
        except (Exception, psycopg2.Error) as error :
            print('Check function databaseFunctions.createExtenson. Cannot execute function. Reason %s.' % (error))
    
    def dropExtension(connection):
        """Remove pggeotec extension and but not the dependencies in PostgreSQL database.
            :param connection: Instance of connection with the database
			:return: No return
		"""
        try:
            cursor = connection.cursor()
            cursor.execute('DROP EXTENSION pggeotec;')
            connection.commit()
            print('Extension droped.')
        except (Exception, psycopg2.Error) as error :
            print('Check function databaseFunctions.createExtenson. Cannot execute function. Reason %s.' % (error))

    def refreshMatviews(connection):
        """Refresh Materialised views in PostgreSQL database.
            :param connection: Instance of connection with the database
			:return: No return
		"""
        try:
            cursor = connection.cursor()
            sql = ('SELECT pggeotec.drop_matviews();')
            cursor.execute(sql)
            connection.commit()
            print('Materialized views recreated.')
        except (Exception, psycopg2.Error) as error :
            print('Check function databaseFunctions.refreshMatviews. Cannot execute function. Reason %s.' % (error)) 

    def executeExtensionFunctionNoParameters(connection, functionName):
        """Execute any Extension Function with no parameters available in PostgreSQL database.
            :param connection: Instance of connection with the database
            :param functionName: Name of the function
			:return: No return
		"""
        try:
            cursor = connection.cursor()
            sql = ('SELECT pggeotec.%s();' % (functionName))
            cursor.execute(sql)
            connection.commit()
            print('%s executed.' % (functionName))
        except (Exception, psycopg2.Error) as error :
            print('Check function databaseFunctions.executeExtensionFunctionNoParameters. Cannot execute function. Reason %s.' % (error)) 

    def executeExtensionFunctionOneParameters(connection, functionName, parameterOne):
        """Execute any Extension Function with one parameters available in PostgreSQL database.
            :param connection: Instance of connection with the database
            :param functionName: Name of the function
            :param parameterOne: Parameter of the function
			:return: No return
		"""
        try:
            cursor = connection.cursor()
            sql = ("SELECT pggeotec.%s('%s');" % (functionName, parameterOne))
            cursor.execute(sql)
            connection.commit()
            print('%s executed.' % (functionName))
        except (Exception, psycopg2.Error) as error :
            print('Check function databaseFunctions.executeExtensionFunctionNoParameters. Cannot execute function. Reason %s.' % (error)) 
    
    def consolidationGenerateData(connection, identifier):
        """Query for data about consolidation test available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param identifier: Name of the consolidation test identifier
            :return variable_one: Pressure of of the consolidation test
            :return variable_two: Void index
		"""
        try:
            variable_one, variable_two = [], []
            query = ("SELECT adm_pressao, adm_ind_vaz FROM el.adensamento_medicao WHERE adm_ident = '%s' ORDER BY adm_pk" %(identifier))
            cursor = connection.cursor()
            cursor.execute(query)
            connection.commit()
            query_result = cursor.fetchall()
            for element in query_result:
                variable_one.append(float(element[0]))
                variable_two.append(float(element[1]))
            return variable_one, variable_two
        except Exception as error:
            print ("databaseFunctions.consolidationGenerateData. Reason: %s" %(error))
    
    def granulometryGenerateData(connection, identifier):
        """Query for data about granulometry test available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param identifier: Name of the granulometry test identifier
            :return variable_one: Pressure of of the consolidation test
            :return variable_two: Void index
            :return g_teor_finos: Fine percentage
            :return g_teor_gro: Coarse percentage
            :return g_diam_efet: Efective diameter
            :return g_coef_unif: Uniformity coeficient
            :return g_coef_curv: Curvature coeficient
            :return g_defloc: If uses or not defloculant
		"""
        try:
            variable_one, variable_two = [], []
            g_teor_finos, g_teor_gro, g_diam_efet, g_coef_unif, g_coef_curv = 0,0,0,0,0
            g_defloc = 'Sem defloculante'
            query = ("""SELECT g_teor_finos, g_teor_gro, g_diam_efet, g_coef_unif, g_coef_curv, g_defloc
                        FROM el.granulometria WHERE g_ident = '%s'"""%(identifier))
            query2 = ("""SELECT gm_abertura, gm_mat_passa FROM el.granulometria_medicao WHERE gm_ident = '%s' ORDER BY gm_abertura DESC"""%(identifier))
            cursor = connection.cursor()
            cursor.execute(query2)
            connection.commit()
            query_result = cursor.fetchall()
            for element in query_result:
                variable_one.append(float(element[0]))
                variable_two.append(float(element[1]))
            cursor.execute(query)
            connection.commit()
            query_result = cursor.fetchall()
            for element in query_result:
                g_teor_finos = float(element[0])
                g_teor_gro = float(element[1])
                g_diam_efet = float(element[2])
                g_coef_unif = float(element[3])
                g_coef_curv = float(element[4])
                if element[5] == True:
                    g_defloc = 'With deflocculant'
                else:
                    g_defloc = 'Without deflocculant'
            return variable_one, variable_two, g_teor_finos, g_teor_gro, g_diam_efet, g_coef_unif, g_coef_curv, g_defloc
        except Exception as error:
            print ("databaseFunctions.granulometryGenerateData. Reason: %s" %(error))
    
    def atterberbGenerateData(connection, identifier):
        """Query for data about atterberg test available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param identifier: Name of the atterberg test identifier
            :return dataframe: Dataframe with la_lp, la_limit_liq, la_ind_plast, la_arg_ativ available in PostgreSQL database 
		"""
        try:
            query = ("SELECT la_lp, la_limit_liq, la_ind_plast, la_arg_ativ FROM el.atterberg WHERE la_ident = '%s';" %(identifier))
            dataframe = read_sql_query(query, connection)
            connection.commit()
            return dataframe
        except Exception as error:
            print ("databaseFunctions.atterberbGenerateData. Reason: %s" %(error))

    def compactacGenerateData(connection, identifier):
        """Query for data about compactation test available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param identifier: Name of the compactation test identifier
            :return dataframe: Dataframe with cm_umid_med, cm_densidade available in PostgreSQL database 
		"""
        try:
            query = ("SELECT cm_umid_med, cm_densidade FROM el.compactacao_medicao WHERE cm_ident = '%s';" %(identifier))
            dataframe = read_sql_query(query, connection)
            connection.commit()
            return dataframe
        except Exception as error:
            print ("databaseFunctions.compactacGenerateData. Reason: %s" %(error))

    def iscGenerateData(connection, identifier):
        """Query for data about California Bearing Ratio test available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param identifier: Name of the California Bearing Ratio  test identifier
            :return dataframe: Dataframe with iscm_penet, iscm_pressao available in PostgreSQL database 
		"""
        try:
            query = ("SELECT iscm_penet, iscm_pressao FROM el.isc_medicao WHERE iscm_ident = '%s' ORDER BY iscm_penet ASC;" %(identifier))
            dataframe = read_sql_query(query, connection)
            connection.commit()
            return dataframe
        except Exception as error:
            print ("databaseFunctions.iscGenerateData. Reason: %s" %(error))
    
    def piezometerGenerateData(connection, identifier):
        """Query for data about piezometer available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param identifier: Name of the piezometer test identifier
            :return dataframe: Dataframe with pz_data_med, pz_na_med available in PostgreSQL database
            :return dataframe_chuvoso: Dataframe with pz_data_med, pz_na_med available in PostgreSQL database on wet season
            :return dataframe_seco: Dataframe with pz_data_med, pz_na_med available in PostgreSQL database on dry season
		"""
        try:
            query = ("SELECT pz_data_med, pz_na_med FROM ic.piezometro WHERE pz_ident = '%s' ORDER BY pz_data_med ASC;" %(identifier))
            query_chuvoso = ("SELECT pz_data_med, pz_na_med FROM ic.piezometro WHERE pz_ident = '%s' AND EXTRACT(MONTH FROM pz_data_med) >= 9 OR EXTRACT(MONTH FROM pz_data_med) <= 4 ORDER BY pz_data_med ASC;" %(identifier))
            query_seco = ("SELECT pz_data_med, pz_na_med FROM ic.piezometro WHERE pz_ident = '%s' AND EXTRACT(MONTH FROM pz_data_med) < 9 OR EXTRACT(MONTH FROM pz_data_med) > 4 ORDER BY pz_data_med ASC;" %(identifier))
            dataframe = read_sql_query(query, connection)
            dataframe_chuvoso = read_sql_query(query_chuvoso, connection)
            dataframe_seco = read_sql_query(query_seco, connection)
            connection.commit()
            return dataframe, dataframe_chuvoso, dataframe_seco
        except Exception as error:
            print ("databaseFunctions.piezometerGenerateData. Reason: %s" %(error))


    def depthWetSPTGenerateData(connection, layer):
        """Query for data about Wet SPT Generate Data available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param layer: Name of the layer of SPT to analize
            :param profund: Depth where the SPT measures were made
            :param minimo: Minimun value of SPT observed in depth param
            :param q1: Q1 value of SPT observed in depth param
            :param mediano: Median value of SPT observed in depth param
            :param media: Mean value of SPT observed in depth param
            :param q3: Q3 value of SPT observed in depth param
            :param maximo: Maximun value of SPT observed in depth param
			:return: No return
		"""
        try:
            query_chuvoso = """
            WITH chuvoso AS (
                    SELECT * FROM ic."""+ layer+""" WHERE ((i_data_ini::text LIKE '%-09-%') OR (i_data_ini::text LIKE '%-10-%')
                    OR (i_data_ini::text LIKE '%-11-%') OR (i_data_ini::text LIKE '%-12-%') OR
                    (i_data_ini::text LIKE '%-01-%') OR (i_data_ini::text LIKE '%-02-%')
                    OR (i_data_ini::text LIKE '%-03-%') OR (i_data_ini::text LIKE '%-04-%')) AND spc_final <= 60
                    AND sdg_profund = TRUNC(sdg_profund) AND spc_final IS NOT NULL
                )
                SELECT
                 min(spc_final),
                 PERCENTILE_CONT(0.25) WITHIN GROUP(ORDER BY spc_final) AS q1,
                 avg(spc_final) AS media,
                 PERCENTILE_CONT(0.5) WITHIN GROUP(ORDER BY spc_final) AS mediana,
                 PERCENTILE_CONT(0.75) WITHIN GROUP(ORDER BY spc_final) AS q3,
                 max(spc_final),
                 sdg_profund
                FROM 
                    chuvoso
                GROUP BY
                    sdg_profund
                ORDER BY
                    sdg_profund ASC
            """
            cursor = connection.cursor()
            cursor.execute(query_chuvoso)
            connection.commit()
            cursor_result = cursor.fetchall()
            profund, minimo, q1, mediano, media, q3, maximo = [],[],[],[],[],[],[]
            for element in cursor_result:
                profund.append(element[6])
                minimo.append(element[0])
                q1.append(element[1])
                media.append(element[2])
                mediano.append(element[3])
                q3.append(element[4])
                maximo.append(element[5])
            return profund, minimo, q1, mediano, media, q3, maximo
        except Exception as error:
            print ("databaseFunctions.depthWetSPTGenerateData. Reason: %s" % (error))

    def depthDrySPTGenerateData(connection, layer):
        """Query for data about Dry SPT Generate Data available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param layer: Name of the layer of SPT to analize
            :param profund: Depth where the SPT measures were made
            :param minimo: Minimun value of SPT observed in depth param
            :param q1: Q1 value of SPT observed in depth param
            :param mediano: Median value of SPT observed in depth param
            :param media: Mean value of SPT observed in depth param
            :param q3: Q3 value of SPT observed in depth param
            :param maximo: Maximun value of SPT observed in depth param
			:return: No return
		"""
        try:
            query_chuvoso = """
            WITH seco AS (
                    SELECT * FROM ic."""+ layer+""" WHERE ((i_data_ini::text LIKE '%-05-%') OR (i_data_ini::text LIKE '%-06-%')
                    OR (i_data_ini::text LIKE '%-07-%') OR (i_data_ini::text LIKE '%-08-%')) AND spc_final <= 60
                    AND sdg_profund = TRUNC(sdg_profund) AND spc_final IS NOT NULL
                )
                SELECT
                 min(spc_final),
                 PERCENTILE_CONT(0.25) WITHIN GROUP(ORDER BY spc_final) AS q1,
                 avg(spc_final) AS media,
                 PERCENTILE_CONT(0.5) WITHIN GROUP(ORDER BY spc_final) AS mediana,
                 PERCENTILE_CONT(0.75) WITHIN GROUP(ORDER BY spc_final) AS q3,
                 max(spc_final),
                 sdg_profund
                FROM 
                    seco
                GROUP BY
                    sdg_profund
                ORDER BY
                    sdg_profund ASC
            """
            cursor = connection.cursor()
            cursor.execute(query_chuvoso)
            connection.commit()
            cursor_result = cursor.fetchall()
            profund, minimo, q1, mediano, media, q3, maximo = [],[],[],[],[],[],[]
            for element in cursor_result:
                profund.append(element[6])
                minimo.append(element[0])
                q1.append(element[1])
                media.append(element[2])
                mediano.append(element[3])
                q3.append(element[4])
                maximo.append(element[5])
            return profund, minimo, q1, mediano, media, q3, maximo
        except Exception as error:
            print ("databaseFunctions.depthDrySPTGenerateData. Reason: %s" % (error))
            
    def depthSPTGenerateData(connection, layer):
        """Query for data about SPT Generate Data available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param layer: Name of the layer of SPT to analize
            :param profund: Depth where the SPT measures were made
            :param minimo: Minimun value of SPT observed in depth param
            :param q1: Q1 value of SPT observed in depth param
            :param mediano: Median value of SPT observed in depth param
            :param media: Mean value of SPT observed in depth param
            :param q3: Q3 value of SPT observed in depth param
            :param maximo: Maximun value of SPT observed in depth param
			:return: No return
		"""
        try:
            query = """
            WITH seco AS (
                    SELECT * FROM ic."""+layer+""" WHERE spc_final <= 60
                    AND sdg_profund = TRUNC(sdg_profund) AND spc_final IS NOT NULL
                )
                SELECT
                 min(spc_final),
                 PERCENTILE_CONT(0.25) WITHIN GROUP(ORDER BY spc_final) AS q1,
                 avg(spc_final) AS media,
                 PERCENTILE_CONT(0.5) WITHIN GROUP(ORDER BY spc_final) AS mediana,
                 PERCENTILE_CONT(0.75) WITHIN GROUP(ORDER BY spc_final) AS q3,
                 max(spc_final),
                 sdg_profund
                FROM 
                    seco
                GROUP BY
                    sdg_profund
                ORDER BY
                    sdg_profund ASC
            """
            cursor = connection.cursor()
            cursor.execute(query)
            connection.commit()
            cursor_result = cursor.fetchall()
            profund, minimo, q1, mediano, media, q3, maximo = [],[],[],[],[],[],[]
            for element in cursor_result:
                profund.append(element[6])
                minimo.append(element[0])
                q1.append(element[1])
                media.append(element[2])
                mediano.append(element[3])
                q3.append(element[4])
                maximo.append(element[5])
            return profund, minimo, q1, mediano, media, q3, maximo
        except Exception as error:
            print ("databaseFunctions.depthSPTGenerateData. Reason: %s" % (error))

    def majority(connectionOne, connectionTwo, gridIds, layerName, variable, majorityDistance, gridName):
        """Interpolate a grid using majority algorithm.
            :param connectionOne: Instance of connection with the database
            :param connectionTwo: Instance of connection with the database
            :param layerName: Name of the layer to analize
            :param gridIds: Field with grid ids for iteration
            :param variable: Variable for majority interpolation
            :param majorityDistance: Distance of search for majority interpolation
            :param gridName: Name of grid layer
			:return: No return
		"""
        try:
            cursorConnectionOne = connectionOne.cursor()
            sql_prepare = ("""ALTER TABLE %s ADD COLUMN IF NOT EXISTS %s Character varying(254)""" % (gridName, variable))
            cursorConnectionOne.execute(sql_prepare)
            connectionOne.commit()
            cursorConnectionTwo = connectionTwo.cursor()
            for gridID in gridIds:
                sql = ("SELECT pggeotec.majority('%s', '%s','%s', '%s', '%s');" % (majorityDistance, str(int(gridID)), layerName, gridName, variable))
                print(sql)
                cursorConnectionTwo.execute(sql)
                connectionTwo.commit()
        except Exception as error:
            print ("databaseFunctions.majority. Reason: %s" % (error))
        finally:
            connectionOne.close()
            connectionTwo.close()
    
    def idw(connectionOne, connectionTwo, gridIds, layerName, variable, majorityDistance, gridName, numberPoints):
        """Interpolate a grid using idw algorithm.
            :param connectionOne: Instance of connection with the database
            :param connectionTwo: Instance of connection with the database
            :param layerName: Name of the layer to analize
            :param gridIds: Field with grid ids for iteration
            :param variable: Variable for majority interpolation
            :param majorityDistance: Distance of search for majority interpolation
            :param gridName: Name of grid layer
            :param numberPoints: Max number of point to use in interpolation
			:return: No return
		"""
        try:
            cursorConnectionOne = connectionOne.cursor()
            sql_prepare = ("""ALTER TABLE %s ADD COLUMN IF NOT EXISTS idw_%s Character varying(254)""" % (gridName, variable))
            cursorConnectionOne.execute(sql_prepare)
            connectionOne.commit()
            cursorConnectionTwo = connectionTwo.cursor()
            for gridID in gridIds:
                sql = ("SELECT pggeotec.idw('%s', '%s','%s', '%s', '%s', '%s');" % (majorityDistance, str(int(gridID)), layerName, gridName, variable, numberPoints))
                print(sql)
                cursorConnectionTwo.execute(sql)
                connectionTwo.commit()
        except Exception as error:
            print ("databaseFunctions.majority. Reason: %s" % (error))
        finally:
            connectionOne.close()
            connectionTwo.close()

    def recoverDataSPTOrigin(connection, layer, geociu):
        """Query for data about SPT available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param layer: Name of the layer of SPT to analize
            :param geociu: Unique code to search in the database
            :return profund: Depth where the SPT measures were made 
            :return var_spc_os_desc: Resistency of soils 
            :return legend_origin_values: Geologic origin of soil (Legend)
            :return legend_origin_text: Geologic origin of soil 
		"""
        try:
            cursor_legend_origin = connection.cursor()
            cursor_legend_origin.execute("SELECT dm_os_pk, dm_os_desc FROM dom.tb_dom_origem_solo")
            cursor_legend_origin_result = cursor_legend_origin.fetchall()
            connection.commit()
            legend_origin_values = []
            legend_origin_text = []
            k = 0 
            for element_legend_origin in cursor_legend_origin_result:
                legend_origin_values.append(float(element_legend_origin[0]))
                legend_origin_text.append(str(element_legend_origin[1]))
                k += 1

            cursor_percussao = connection.cursor()
            cursor_percussao.execute("SELECT sdg_profund, spc_os_desc FROM ic.%s WHERE sdg_geociu = '%s' ORDER BY sdg_profund ASC " % (layer, geociu))
            cursor_percussao_result = cursor_percussao.fetchall()
            connection.commit()
            profund, var_spc_os_desc  = [], []
            for m in cursor_percussao_result:
                var_spc_os_desc.append(m[1])
                profund.append(m[0])       
            return profund, var_spc_os_desc, legend_origin_values, legend_origin_text
        except Exception as error:
            print ("databaseFunctions.recoverDataSPTOrigin. Reason: %s" % (error))
    
    def recoverDataSPTTexture(connection, layer, geociu):
        """Query for data about SPT available in PostgreSQL database to create a graphic.
            :param connection: Instance of connection with the database
            :param layer: Name of the layer of SPT to analize
            :param geociu: Unique code to search in the database
            :return profund: Depth where the SPT measures were made 
            :return var_spc_text_prim: Primary texture of soil
            :return var_spc_text_sec: Secondary texture of soil
            :return var_spc_text_comp: Complemetary texture of soil
            :return texture_values: Texture of soil (Legend)
            :return texture_text: Texture of soil 
		"""
        try:
            cursor_legend_texture = connection.cursor()
            cursor_legend_texture.execute("SELECT dm_text_pk, dm_text_desc FROM dom.tb_dom_textura_solo")
            cursor_legend_texture_result = cursor_legend_texture.fetchall()
            connection.commit()
            texture_values, texture_text = [], []
            w = 0 
            for element_texture in cursor_legend_texture_result:
                texture_values.append(float(element_texture[0]))
                texture_text.append(str(element_texture[1]))
                w += 1

            cursor_percussao = connection.cursor()
            cursor_percussao.execute("SELECT sdg_profund, spc_text_prim, spc_text_sec, spc_text_comp FROM ic.%s WHERE sdg_geociu = '%s' ORDER BY sdg_profund ASC " % (layer, geociu))
            cursor_percussao_result = cursor_percussao.fetchall()
            connection.commit()
            profund, var_spc_os_desc, var_spc_text_prim, var_spc_text_sec, var_spc_text_comp = [], [], [], [], []
            for m in cursor_percussao_result:
                var_spc_text_prim.append(m[1])
                var_spc_text_sec.append(m[2])
                var_spc_text_comp.append(m[3])
                profund.append(m[0])       
            return profund, var_spc_text_prim, var_spc_text_sec, var_spc_text_comp, texture_values, texture_text
        except Exception as error:
            print ("databaseFunctions.recoverDataSPTTexture. Reason: %s" % (error))
